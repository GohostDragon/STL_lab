

===============================================
저장시간 : 2021-03-02 오후 3:01:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 2일 화요일				(1주 1일)
// 
// 실행될때마다 소스파일을 저장한다
//----------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string_view>
#include <filesystem>
#include <fstream>
#include <ctime>
using namespace std;

void save(string_view );

int main()
{
	save("소스.cpp");
}

// google coding convention
void save( string_view fileName )
{
	// 어떤 파일을 저장하는지 화면에 출력한다. - 파일이름과 크기
	cout << "저장: " << fileName << ", 크기: " << filesystem::file_size(fileName) << endl;

	ofstream out("2021 1학기 STL 화56목56 강의저장.txt", ios::app);

	ifstream in(fileName); // 파일을 읽는다. <- 지역변수라 블록을 나가면 알아서 삭제 해줌

	out << endl << endl;

	// 파일을 기록한 시간도 쓴다.
	time_t t = time( nullptr );

	out.imbue(locale("korean"));

	out << "===============================================" << endl;
	out << "저장시간 : " << put_time( localtime(&t), "%c %A") << endl;
	out << "===============================================" << endl;
	int c;
	while ((c = in.get()) != EOF)
		out.put(c);

	// RAII
}


===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
#pragma once

#include <string_view>
void save(std::string_view);

===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
#include <iostream>
#include <filesystem>
#include <fstream>
#include "save.h"

// google coding convention
void save(std::string_view fileName)
{
	// 어떤 파일을 저장하는지 화면에 출력한다. - 파일이름과 크기
	std::cout << "저장: " << fileName << ", 크기: " << std::filesystem::file_size(fileName) << std::endl;

	std::ofstream out("2021 1학기 STL 화56목56 강의저장.txt", std::ios::app);

	std::ifstream in(fileName); // 파일을 읽는다. <- 지역변수라 블록을 나가면 알아서 삭제 해줌

	using std::endl;

	out << endl << endl;

	// 파일을 기록한 시간도 쓴다.
	time_t t = time(nullptr);

	out.imbue(std::locale("korean"));

	out << "===============================================" << endl;
	out << "저장시간 : " << std::put_time(localtime(&t), "%c %A") << endl;
	out << "===============================================" << endl;
	int c;
	while ((c = in.get()) != EOF)
		out.put(c);

	// RAII
}

===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 2일 화요일				(1주 1일)
// 
// 실행될때마다 소스파일을 저장한다
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}


===============================================
저장시간 : 2021-03-04 오후 1:51:34 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// Game은 사용자가 정의한 클래스이다.
// 화면출력은 2, 1

int main()
{
	/*
	Game a{ 1 };
	Game b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	*/
	save("소스.cpp");
}


===============================================
저장시간 : 2021-03-04 오후 2:01:22 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// Game은 사용자가 정의한 클래스이다.
// 화면출력은 2, 1

class Game {
public:
	Game(int n) : n{ n } {}

private:
	int n;

	friend ostream& operator<<(ostream& os, const Game& game);
};


void change(Game&, Game&);

int main()
{
	Game a{ 1 };
	Game b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(Game& a, Game& b)
{
	Game temp{ a };
	a = b;
	b = temp;
}

ostream& operator<<(ostream& os, const Game& game)
{
	os << game.n;
	return os;
}

===============================================
저장시간 : 2021-03-04 오후 2:09:30 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// 앞에서 만든 change()가 다른 자료형도 바꿀 수 있도록하자
// 화면출력은 2, 1

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:40:55 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10]{ 1,345456,48456465,846546,2 };

	for (int i = 0; i < 10; i++)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:44:10 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:46:20 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	cout << numeric_limits<int>::max() << endl;

	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:46:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	//int 최대값
	cout << numeric_limits<int>::max() << endl;
	//int 최소값
	cout << numeric_limits<int>::min() << endl;

	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:47:54 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid{ 0,100 };

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:53:06 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[100];

	default_random_engine dre;
	uniform_int_distribution uid{ 0,100 };

	cout << sizeof(dre) << endl;

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:56:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid;

	cout << sizeof(dre) << endl;

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:57:14 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:57:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 3:11:31 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자
// 값을 오름차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort( begin(a), end(a) );

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 3:16:42 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		}/*어떻게 정렬할지 사용자가 알려주면 된다. -> 함수를 전달 */);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:38:06 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		}/*어떻게 정렬할지 사용자가 알려주면 된다. -> 함수를 전달 */);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:38:38 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a));

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:18 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:41 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:48:35 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

bool x(int a, int b)
{
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:50:33 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int xcount = 0;

bool x(int, int);

bool x(int a, int b)
{
	xcount++;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << xcount << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:52:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:52:38 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	cout << a << " -- " << b << endl;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:53:34 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	return a > b;
}

int main()
{
	int a[1000];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:03:02 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1000];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?
	int cnt{};
	sort(begin(a), end(a), [&cnt](int a, int b) {
		++cnt;
		return a > b;
		});	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:10:15 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1000];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:12:15 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1'000];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:13:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1'000'00];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:32:01 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[10'000'00]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:32:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[100'000'000]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:34:51 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[100'000'000]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:44:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <filesystem>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	std::ofstream out("int 100개.txt", std::ios::app);
	for (int n : a)
		out << n << " ";

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:48:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	ofstream out( "오름차순정렬한 int 100개.txt"s );
	for (int n : a)
		out << n;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:49:41 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	ofstream out( "오름차순정렬한 int 100개.txt"s );
	for (int n : a)
		out << n << ' ';

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:54:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{

	ifstream in("오름차순정렬한 int 100개.txt"s);
	int c;
	while ((c = in.get()) != EOF)
		cout << c;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:00:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}
	int c;
	while ((c = in.get()) != EOF)
		cout << c;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:01:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:03:08 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}

	int a[100];

	for (int& n : a)
		in >> n;

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:14:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	for (int a : a)
		cout << a << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:16:12 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	ofstream out("int 100개.txt");

	out.write((char *)a, 100 * sizeof(int));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:17:58 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	ofstream out("int 100개.txt", ios::binary);

	out.write((char *)a, 100 * sizeof(int));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:39:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개를 화면에 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int n;
	for (int i = 0; i < 100; i++){
		in.read((char *)&n, sizeof(int));
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:44:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 int 100개를 내림차순으로 정렬한 후 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int a[100];
	in.read((char*)a, 100 * sizeof(int));
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:47:01 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 int 100개를 내림차순으로 정렬한 후 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int a[100];
	in.read((char*)a, 100 * sizeof(int));
	
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		});

	for (int x : a)
		cout << x << '\t';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 2:14:19 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	cout << "몇 개의 int를 원하나요?";
	int num;
	cin >> num;

	int* p = new int[num];

	for (int i = 0; i < num; ++i)
		p[i] = i + 1;

	cout << "처음 - " << p[0] << endl;
	cout << "마지막 - " << p[num-1] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 2:15:52 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:16:12 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:22:48 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p;
		try{
			p = new int[num];
		}
		catch (exception& e) {
			cout << e.what() << endl;
			continue;
		}

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:40:33 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 조금씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[500'000'000];
		cout << ++cnt << " 할당 성공" << endl;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:44:23 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 
// 3초에 한번씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[200'000'000];
		cout << ++cnt << " 할당 성공" << endl;
		this_thread::sleep_for(3s);
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:47:53 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 
// 3초에 한번씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[200'000'000];
		cout << ++cnt << " 할당 성공" << endl;
		this_thread::sleep_for(1s);
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:56:50 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// core c++ guidelines - raw pointer 를 사용하지 말 것

int main()
{
	save("소스.cpp");

	int cnt{};
	while (true) {
		char* p = new char[500'000'000];

		cout << ++cnt << '\r';

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:58:47 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// core c++ guidelines - raw pointer 를 사용하지 말 것

int main()
{
	save("소스.cpp");

	int cnt{};
	while (true) {
		unique_ptr<char> p{ new char[500'000'000] };

		cout << ++cnt << '\r';

		//delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 3:15:37 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(100ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간 - " << d.count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:18:00 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(100ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:18:34 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(333ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:20:36 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	using namespace std::chrono;

	steady_clock::time_point b = steady_clock::now();		// 스톱워치 시작
	
	this_thread::sleep_for(333ms);

	auto d = steady_clock::now() - b;

	cout << "경과시간(밀리초) - " << duration_cast<milliseconds>(steady_clock::now() - b).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:46:08 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;
	string name;

	static int cnt;

friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:48:28 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	Dog(const Dog&) {
		cout << "복사" << endl;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:48:50 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	Dog(const Dog&) {
		cout << "복사" << endl;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog& dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:51:22 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// sizeof( Dog )를 확인하자


default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	cout << "Dog 한 객체가 차지하는 메모리 - " << sizeof(Dog) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:54:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// sizeof( Dog )를 확인하자


default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id( uid(dre) ) {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	char id;			// 1
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	cout << "Dog 한 객체가 차지하는 메모리 - " << sizeof(Dog) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:05:33 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10000];
	ofstream out("Dog 만객체.txt"s);
	for (const Dog& n : dogs)
		out << n << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:10:46 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	for (const Dog& dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:13:49 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	ofstream out{ "Dog 만객체.txt", ios::binary };
	out.write( (char *)&dogs[0], sizeof(Dog) * 100000);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:15:22 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	ofstream out{ "Dog 만객체.txt", ios::binary };
	out.write( (char *)&dogs[0], sizeof(Dog) * 10'000);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:20:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	Dog* dogs = new Dog[10'000];

	in.read( (char *)dogs, sizeof(Dog) * 10'000);

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:34:24 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include <memory>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	~Dog() {
		cout << "소멸" << endl;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	unique_ptr<Dog[]> dogs{ new Dog[10'000] };

	in.read( (char *)dogs.get(), sizeof(Dog) * 10'000);

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:44:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include <memory>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	int getID() const {
		return id;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	unique_ptr<Dog[]> dogs{ new Dog[10'000] };

	in.read( (char *)dogs.get(), sizeof(Dog) * 10'000);

	// id 오름차순으로 정렬한다.
	sort(&dogs[0], &dogs[10'000], [](const Dog& a, const Dog& b) {
		return a.getID() < b.getID();
		});

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:49:45 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	x();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:51:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	x();

	cout << typeid(x).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:53:44 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	auto y = []() {
		cout << "안녕" << endl;
	};

	cout << typeid(x).name() << endl;
	cout << typeid(y).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:57:31 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) {
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	f(1);
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:58:11 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) {
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	(*f)(1);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:00:32 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	// f를 다른 변수 a에 저장할 수 있니?
	auto a = f;

	cout << typeid(a).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:02:18 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	// f를 다른 변수 a에 저장할 수 있니?
	void(*a)(int) = f;

	a(123);

	cout << typeid(a).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:06:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}
};

int main()
{
	Test t;

	t(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:09:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}

	void  (*m)(int) = f;
};

int main()
{
	Test t;

	t(123);

	t.m(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:10:34 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}

	void  (*m)(int) = f;
};

auto x = [](int) -> void {
	cout << "람다" << endl;
};

int main()
{
	x(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:14:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// 쿠키런
// 왼쪽버튼 - 점프, 오른쪽버튼 - 슬라이드
//
// 설정에 가서 버튼을 바꿨다.
// 프로그램 구현은 어떻게 했겠니?

void left()
{
	cout << "점프" << endl;
}

int main()
{
	save("소스.cpp");

	while (true) {
		left();
		this_thread::sleep_for(500ms);
	}
}

===============================================
저장시간 : 2021-03-16 오후 3:19:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// 쿠키런
// 왼쪽버튼 - 점프, 오른쪽버튼 - 슬라이드
//
// 설정에 가서 버튼을 바꿨다.
// 프로그램 구현은 어떻게 했겠니?

void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}

void (*left_function)() = jump;

void left()
{
	left_function();
}

int main()
{
	save("소스.cpp");

	// 10번에 한번은 기능을 바꾼다

	int cnt{};

	while (true) {
		left();
		this_thread::sleep_for(500ms);
		++cnt;
		if (cnt == 10) {
			left_function = slide;
		}
	}
}

===============================================
저장시간 : 2021-03-18 오후 1:37:01 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

int main()
{
	int a;

	auto f = jump;

	cout << typeid(f).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:47:27 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

int main()
{
	int a;

	void (*f)(void);

	cout << "함수 포인터의 크기 - "<< sizeof(f) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:49:18 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:50:08 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "f의 번지 - " << f << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:50:55 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:51:54 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;
	cout << "변수 f의 번지 - " << &f <<endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:52:32 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;
	cout << "변수 f의 번지 - " << &f <<endl;

	int a;
	cout << "스택의 번지 - " << &a << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:59:27 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

int main()
{
	f(1);
	Test t;
	t(2);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:03:48 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
void (*lamda)(int) = [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);
	//질문? 람다의 타입은?

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:06:09 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);
	//질문? 람다의 타입은?
	cout << typeid(lamda).name() << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:13:37 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);

	t.mf(4);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:18:41 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	void (*ct)(int) = f;
	ct(1);

	//Test t;
	//ct = void ((*t)) (int)

	//ct(2);
	
	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);

	// ct = &Test::mf;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:33:26 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	void (*ct)(int) = f;
	ct(1);

	Test t;
	//ct = void ((*t)) (int)

	//ct(2);
	
	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);

	void (Test::*pmf)(int) = &Test::mf;
	(t.*pmf)(4);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:43:22 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	function<void(int)> ct;

	ct = f;
	ct(1);

	Test t;
	ct = t;
	ct(2);

	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);


	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:00:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,255 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:29 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,255 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,100 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:43 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,100 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:51 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:18 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << &game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:33 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << *game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:50 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:10:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:10:59 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s{ 2021 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:13:15 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for ( String s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:14:15 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:18:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 1:50:43 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for (String& s : s)
		cout << s << endl;

	cout << endl << "---------------------" << endl;
	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 1:52:01 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	//sort(begin(s), end(s), [](const String& a, const String& b){
	//	return a.size() < b.size();
	//	});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:05:47 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:15:05 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending()
	{
		sort(p, p + num, [](const char& a, const char& b) {
			return a < b;
			});
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	// [문제] 각 String을 알파벳 오름차순으로 정렬하라.
	for (String& s : s)
		s.sortAscending();

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:31:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	// [문제] 각 String을 알파벳 오름차순으로 정렬하라.
	for (String& s : s)
		s.sortAscending();

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:39:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };
uniform_int_distribution<> uidLen{ 1, 200 };

class String {
public:
	String() : num{ uidLen(dre) }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:40:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };
uniform_int_distribution<> uidLen{ 1, 200 };

class String {
public:
	String() : num{ uidLen(dre) }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() > b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:44:05 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자



// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() > b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:59:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 사용자가 입력하는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{}, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 3:01:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 사용자가 입력하는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{ cin}, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 3:05:06 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{ in }, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오전 9:34:09 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{ in }, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 1:54:00 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{ in }, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 1:59:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v{ 1,2,3 };

	for (vector<int>::iterator i = v.begin(); i != v.end(); i++)
		cout << *i << endl;
	cout << sizeof(v) << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:06:44 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<vector <int> > v{ {1,2,3}, {4,5,6,7,8}, {100,200,300} };

	for (auto i = v.begin(); i != v.end(); ++i) {
		auto t = *i;
		for (auto ti = t.begin(); ti != t.end(); ++ti)
			cout << *ti << " ";
		cout << endl;
	}
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:20:40 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] array의 특성을 살펴본다.
int main()
{
	array<int, 10> a{ 1,2,3,4,5 };
	cout << a[0] << endl;
	cout << a[10] << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:35:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] array의 특성을 살펴본다.
int main()
{
	array<int, 10> a{ 1,2,3,4,5 };

	try {
		cout << a.at(10) << endl;
	}
	catch (exception& e) {
		cout << e.what() << endl;
	}

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:40:14 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] array의 특성을 살펴본다.
int main()
{
	array<int, 10> a{ 1,2,3,4,5 };

	array<int, 10> b;

	a = b;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:41:35 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] array의 특성을 살펴본다.
int main()
{
	array<int, 10> a;
	array<int, 100> b;

	cout << sizeof(a) << endl;
	cout << sizeof(b) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 2:53:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}
};

int main()
{
	Array<int, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	//for (auto i = a.begin(); i != a.end(); ++i)
	//	cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:00:05 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T& operator[](int idx) {
		return data[idx];
	}
};

int main()
{
	Array<int, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	//for (auto i = a.begin(); i != a.end(); ++i)
	//	cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:00:48 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}
};

int main()
{
	Array<int, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	//for (auto i = a.begin(); i != a.end(); ++i)
	//	cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:02:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<int, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:08:14 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<int, 3> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	cout << "반복자로 출력" << endl;

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:08:42 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<String, 3> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	cout << "반복자로 출력" << endl;

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:09:19 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<String, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	cout << "반복자로 출력" << endl;

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:17:04 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<String, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	cout << "반복자로 출력" << endl;

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오후 3:18:22 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 25일 목요일				(4주 2일)
//
// 컨테이너는 다른 객체를 저장하는 객체이다.
// Sequence Containers
//			- array
//			- vector
//			- deque
//			- forward_list
//			- list
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array를 프로그램하라

template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}

	size_t size() const {
		return N;
	}

	T operator[](int idx) const {
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}

	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<String, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i * i;

	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;
	
	cout << "반복자로 출력" << endl;

	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:36:45 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	String s{ 20 };
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:37:17 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	String s{ 20 };
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:41:02 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	new String { 20 };
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:42:12 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

String s{ 20 };

int main()
{
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:52:53 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] String이 const char*를 인자로 받도록 하자

int main()
{
	String s{ "스트링을 만들어 본다." };

	cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:56:50 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<String, 3> words{"안녕", "낼 모레", "4월이야"};
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 1:59:10 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<String, 3> words;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:02:13 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<int, 10> a;

	cout << a.size() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:02:53 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<int,100'000> a;

	cout << a.size() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:05:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:07:21 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };
	
	int n{ 123 };
	cout << "array<String, 3>이 생성된 위치 - " << &words << endl;
	cout << "여기와 유사한 위치여야 - " << &n << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:16:40 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다

int main()
{
//	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };
	array<String, 3> words{10, 20, 30};

	for (const String& s : words)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:37:10 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:37:38 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() > b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:38:35 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주", "5과제를", "1준비하겠어요" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() > b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:39:32 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ 10, 10, 10 };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:41:34 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ 10, 10, 10 };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:42:13 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ 10, 10, 10 };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() > b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:43:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주", "5과제를", "1준비하겠어요" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:44:42 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주", "5과제를", "1준비하겠어요" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:53:00 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주주주주", "5과제를", "1준비" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 2:55:15 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주주주주", "5과제를", "1준비" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 3:00:08 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다
// 사전 순서(lexicographical) 상 오름차순으로 정렬한다.

int main()
{
	array<String, 3> words{ "3다음주주주주", "5과제를", "1준비" };

	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	for (const String& word : words)
		cout << word << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 3:10:02 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해본다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [질문] [] 과 array 중 무엇을 사용하면 좋은가?
// 메모리상의 장단점은 없다. (스피드상에서도 겨를만한 내용이 없다)
// 나머지는 array의 장점(. 찍으면 나오는게 많다 -> 이용할 수 있는게 많다)
// 앞으로 array를 사용해야 한다.

int main()
{
	int a[10]{ };
	array<int, 10> aa{ };

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 3:17:11 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
//동적 <-> 컴파일 타입
// [문제] vector란 무엇입니까? - 동적(컴파일시에는 크기를 알 수 없는) 배열입니다.

int main()
{
	vector<int> v{ 1, 2, 3 };

	cout << "원소 갯수는 몇 개니? - " << v.size() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-30 오후 3:17:51 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 30일 화요일				(5주 1일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
//동적 <-> 컴파일 타입
// [문제] vector란 무엇입니까? - 동적(컴파일시에는 크기를 알 수 없는) 배열입니다.

int main()
{
	vector<int> v{ 1, 2, 3 };

	cout << "원소 갯수는 몇 개니? - " << v.size() << endl;
	v.push_back(10);
	cout << "원소 갯수는 몇 개니? - " << v.size() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 1:42:31 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] int를 입력받아 합계와 평균값을 출력하라.

int main()
{
	vector<int> v;

	cout << "숫자를 입력하시오. 그만 두려면 Ctrl+z를 입력하세요" << endl;
	int num;
	while (cin >> num)
		v.push_back(num);

	cout << "계산 가능" << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 1:47:53 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] int를 입력받아 합계와 평균값을 출력하라.

int main()
{
	vector<int> v;

	cout << "숫자를 입력하시오. 그만 두려면 int 이외의 입력" << endl;
	int num;
	while (cin >> num)
		v.push_back(num);

	double sum{};
	for (int n : v)
		sum += n;

	cout << "합계: " << sum << ", 평규니 " << sum / v.size() << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 1:53:10 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 객체 v의 차지하는 메모리 크기를 살펴본다.

int main()
{
	vector<int> v;
	vector<int> v1{ 1,11,333,4444,44444 };
	vector<String>v2;
	
	cout << sizeof(v) << ", " << sizeof(v1) << "," << sizeof(v2) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:10:12 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] vector는 4바이트인 멤버변수 3개가 있다.
// 한개는 - 동적할당한 주소를 저장하고 았다.
// 한개는 - 원소갯수를 저장하고 있다.
// 한개는 - 아직 모른다.

// 동적할당한 주소값을 가져와서 그 주소의 내용을 v.size()만큼
// 출력한다면 모든 원소의 출력될 것이다.
// 남은 시간 동안 해본다.

int main()
{
	vector<int> v{ 1, 2, 3, 10 , 200, 4000, 7777777 };

	for (auto& v : v)
	{
		cout << v << endl;
	}

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:36:04 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] vector는 4바이트인 멤버변수 3개가 있다.
// 한개는 - 동적할당한 주소를 저장하고 았다.
// 한개는 - 원소갯수를 저장하고 있다.
// 한개는 - 아직 모른다.

// 동적할당한 주소값을 가져와서 그 주소의 내용을 v.size()만큼
// 출력한다면 모든 원소의 출력될 것이다.

int main()
{
	vector<int> v{ 1, 2, 3, 10 , 200, 4000, 7777777 };

	//int** p = (int**)&v;
	int** p = reinterpret_cast<int**>(&v);
	for (int i = 0; i < v.size(); ++i)
		cout << *p++ << ", ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:37:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] vector는 4바이트인 멤버변수 3개가 있다.
// 한개는 - 동적할당한 주소를 저장하고 았다.
// 한개는 - 원소갯수를 저장하고 있다.
// 한개는 - 아직 모른다.

// 동적할당한 주소값을 가져와서 그 주소의 내용을 v.size()만큼
// 출력한다면 모든 원소의 출력될 것이다.

int main()
{
	vector<int> v{ 1, 2, 3, 10 , 200, 4000, 7777777 };

	//int** p = (int**)&v;
	int** p = reinterpret_cast<int**>(&v);
	for (int i = 0; i < v.size(); ++i)
		cout << *((*p)+i) << ", ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:42:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v{ 1,2,3 };

	cout << "v의 원소 갯수 - " << v.size() << endl;

	v.push_back(456);
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:57:07 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v{ 1,2,3 };

	cout << "v가 저장한 원소의 위치 - " << v.data() << endl;
	cout << "v가 저장한 원소의 갯수 - " << v.size() << endl;
	cout << "재할당없이 저장할 수 있는 갯수 - " << v.capacity() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:57:32 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v{ 1,2,3,4,5,6,7 };

	cout << "v가 저장한 원소의 위치 - " << v.data() << endl;
	cout << "v가 저장한 원소의 갯수 - " << v.size() << endl;
	cout << "재할당없이 저장할 수 있는 갯수 - " << v.capacity() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:58:13 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v( 100 );

	cout << "v가 저장한 원소의 위치 - " << v.data() << endl;
	cout << "v가 저장한 원소의 갯수 - " << v.size() << endl;
	cout << "재할당없이 저장할 수 있는 갯수 - " << v.capacity() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 2:58:28 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<int> v;

	cout << "v가 저장한 원소의 위치 - " << v.data() << endl;
	cout << "v가 저장한 원소의 갯수 - " << v.size() << endl;
	cout << "재할당없이 저장할 수 있는 갯수 - " << v.capacity() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-01 오후 3:19:10 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 1일 화요일				(5주 2일)
//
// - vector
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 거꾸로 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> c) {
		v.push_back(c);
	}

	for (auto i = v.rbegin(); i != v.rend(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 1:55:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 거꾸로 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> c) {//형식화된(서식화된) 입출력 = formatted IO
		v.push_back(c);
	}

	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 1:56:01 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 거꾸로 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> c) {//형식화된(서식화된) 입출력 = formatted IO  => 공간을 자동으로 건너뜀  ab c => abc
		v.push_back(c);
	}

	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 1:57:18 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 거꾸로 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> noskipws >> c) {//ws(wirte space)를 스킵하지 말아라
		v.push_back(c);
	}

	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 1:57:35 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 거꾸로 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> noskipws >> c) {//ws(wirte space)를 스킵하지 말아라
		v.push_back(c);
	}

	for (auto i = v.rbegin(); i != v.rend(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:03:26 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후
// 소문자를 대문자로 바꿔 화면에 출력하라

int main()
{
	ifstream in{ "소스.cpp" };

	vector<char> v;

	char c;
	while ( in >> noskipws >> c) {//ws(wirte space)를 스킵하지 말아라
		v.push_back(c);
	}

	//여기에서 v에 있는 글자 중 소문자를 대문자로 바꾼다.
	for (char& c : v)
		c = toupper(c);

	for (auto i = v.begin(); i != v.end(); ++i)
		cout << *i;

	cout << endl << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:11:39 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555};

	int** p = reinterpret_cast<int**>(&v);

	cout << **p << endl;
	*p++;
	cout << **p << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:12:07 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555};

	int** p = reinterpret_cast<int**>(&v);

	cout << **p << endl;
	*p++;
	cout << *(*p + 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:12:14 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555};

	int** p = reinterpret_cast<int**>(&v);

	cout << **p << endl;
	cout << *(*p + 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:13:05 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555};

	int** p = reinterpret_cast<int**>(&v);

	for (int i = 0; i < v.size(); ++i)
		cout << *(*p + i) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:13:48 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555, 666666, 7777777};

	int** p = reinterpret_cast<int**>(&v);

	for (int i = 0; i < v.size(); ++i)
		cout << *(*p + i) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:14:47 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector는 어떻게 메모리를 관리하는가? - 12 바이트 객체이다.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// vector는 멤버 변수 3개가 있다.
// 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제 데이터를 access 하라

int main()
{
	vector<int> v{1, 22, 333, 4444, 55555, 666666, 7777777};

	int* p = v.data();

	for (int i = 0; i < v.size(); ++i)
		cout << *(p + i) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:17:56 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	for (String s : v)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:18:29 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	for (String s : v)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:36:46 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	for (String s : v)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:38:28 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	for (String& s : v)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:45:10 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.push_back("반가워!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:46:25 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.push_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:54:39 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ "안녕?", "벡터야!" };

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.push_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:57:58 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v;
	v.reserve(3);
	v = { "안녕?", "벡터야!" };

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.push_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 2:59:42 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v;
	v.reserve(3);
	v.push_back("안녕?");
	v.push_back("벡터야!");

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.push_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 3:05:24 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v;
	v.reserve(3);
	v.emplace_back("안녕?");
	v.emplace_back("벡터야!");

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.emplace_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 3:06:28 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v;
	v.reserve(3);
	v.emplace_back("안녕?"); // 스텍을 만들어서 이동 생성자로 쓰지 말고 그냥 벡터에서 만들어라!
	v.emplace_back("벡터야!");

	cout << endl;
	cout << " --추가 하기 전-------------------------- " << endl;
	cout << endl;

	v.emplace_back("반갑습니다!");

	cout << endl;
	cout << " --추가 한 후-------------------------- " << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 3:11:41 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
// - 사용자 정의 자료형이 자원을 관리하는 클래스라면
//  - 이동생성과 이동할당연산자를 반드시 구현해야 한다.
//  - 자료구조에 원소를 추가할때 emplace를 이용하자
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ 20, 10, 30 };
	
	cout << endl;
	cout << " 정렬 전 --------------------" << endl;
	cout << endl;


	cout << endl;
	cout << " 정렬 후 --------------------" << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-06 오후 3:15:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 6일 화요일				(6주 1일)
//
// vector가 진짜 자료형을 관리할 수 있게 하자.
// - 사용자 정의 자료형이 자원을 관리하는 클래스라면
//  - 이동생성과 이동할당연산자를 반드시 구현해야 한다.
//  - 자료구조에 원소를 추가할때 emplace를 이용하자
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<String> v{ 20, 10, 30 };
	

	//v를 길이 오름차순으로 정렬하시오

	cout << endl;
	cout << " 정렬 전 --------------------" << endl;
	cout << endl;

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	cout << endl;
	cout << " 정렬 후 --------------------" << endl;
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:32:09 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
// 
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:37:17 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 3, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }

	v.insert(v.begin() + 3, 3);
	for (auto& it : v)
		cout << it << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:37:38 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }

	v.insert(v.begin() + 3, 3);
	for (auto& it : v)
		cout << it << ", ";
	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:43:41 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, 3);

	for (int i=0; i<v.size(); ++i )
		cout << v[i] << " ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:45:18 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, {3, 3, 3, 3, 3});

	for (int i=0; i<v.size(); ++i )
		cout << v[i] << " ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:45:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, 100, 33333);

	for (int i=0; i<v.size(); ++i )
		cout << v[i] << " ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:47:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, v.begin(), v.end());

	for (int i=0; i<v.size(); ++i )
		cout << v[i] << " ";
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:52:14 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, 3);

	for (auto i = v.cbegin(); i != v.cend(); ++i )
		cout << *i << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:54:00 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <unordered_set>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	unordered_set<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, 3);

	for (auto i = v.cbegin(); i != v.cend(); ++i )
		cout << *i << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 1:56:06 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다.
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<int> v{1, 2, 4, 5};

	// [문제] v에 3을 끼워 넣어본다. { 1, 2, 3, 4, 5 }
	auto p = v.begin();
	advance(p, 2);

	v.insert(p, 3);

	for (auto i = v.cbegin(); i != v.cend(); ++i )
		cout << *i << ' ';
	cout << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 2:23:57 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	// [문제] v에서 홀수를 제거하라.
    for (auto it = v.begin(); it != v.end(); ) {
        if (*it % 2 == 1) {
            it = v.erase(it);
        }
        else {
            ++it;
        }
    }
    for (auto& i : v) {
        cout << i << " ";
    }
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 2:46:12 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    for (int n : v)
        cout << n << ' ';
    cout << endl;

	// [문제] v에서 홀수를 제거하라.
    remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return (val & 1);
        });
    cout << "홀수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 2:47:26 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    for (int n : v)
        cout << n << ' ';
    cout << endl;

	// [문제] v에서 홀수를 제거하라.
    remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return !(val & 1);
        });
    cout << "짝수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 2:56:12 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	// [문제] v에서 홀수를 제거하라.
    auto p = remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return (val & 1);
        });

    v.erase(p, v.end());

    cout << "홀수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 2:58:47 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	// [문제] v에서 홀수를 제거하라.
    auto p = remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return (val & 1);
        });

    v.erase(p, v.end());

    cout << "v가 확보한 메모리 크기: - " << v.capacity() << endl;

    cout << "홀수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:00:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	// [문제] v에서 홀수를 제거하라.
    auto p = remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return (val & 1);
        });

    v.erase(p, v.end());
    v.shrink_to_fit(); // 딱 맞게 용량을 줄어둠

    cout << "v가 확보한 메모리 크기: - " << v.capacity() << endl;

    cout << "홀수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:01:54 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };


	// [문제] v에서 홀수를 제거하라.
    auto p = remove_if(v.begin(), v.end(), []( int val ) { // & 쓸때는 자료형이 포인터보다 클때만 쓴다
        return (val & 1);
        });

    v.erase(p, v.end());
    v.shrink_to_fit(); // 딱 맞게 용량을 줄어둠 -> 메모리 다시 새로 잡아야하는 동작이다.

    cout << "v가 확보한 메모리 크기: - " << v.capacity() << endl;

    cout << "홀수를 제거한 후 " << endl;
    for (int n : v) 
        cout << n << ' ';
    cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:07:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// vector<int> 에서 짝수를 삭제한다. 
// - remove가 지우는 건 진짜가 아니다.
// - 실제 지우는 건 자료구조가 해야 한다.
//
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:10:26 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// deque
// 
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<String> d;

	d.push_back("back"); 
	d.push_front("front");

	for (const String& s : d)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:12:47 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// deque
// 
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<String> d;

	d.emplace(d.end(), "back");
	d.emplace(d.begin(), "front");

	for (const String& s : d)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:16:32 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// deque
// 
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<String> d;

	d.emplace(d.end(), "back");
	d.emplace(d.begin(), "front");

	for (const String& s : d)
		cout << s << endl;

	// 중간에 "middle"을 추가하자

	d.emplace(d.begin()++, "middle");

	cout << "추가한 후 출력" << endl;
	for (const String& s : d)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:16:50 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// deque
// 
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<String> d;

	d.emplace(d.end(), "back");
	d.emplace(d.begin(), "front");

	for (const String& s : d)
		cout << s << endl;

	// 중간에 "middle"을 추가하자

	d.emplace(++d.begin(), "middle");

	cout << "추가한 후 출력" << endl;
	for (const String& s : d)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-04-08 오후 3:19:25 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 4월 8일 화요일				(6주 2일)
//
// deque
// 
// 중간시험 - 4월 22일 (목요일) (8주 2일)
//----------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;



int main()
{
	deque<String> d;

	d.emplace(d.end(), "1");
	d.emplace(d.end(), "2");

	for (const String& s : d)
		cout << s << endl;

	// 중간에 "middle"을 추가하자

	d.emplace(d.end(), "3");

	cout << "추가한 후 출력" << endl;
	for (const String& s : d)
		cout << s << endl;

	save("소스.cpp");
}