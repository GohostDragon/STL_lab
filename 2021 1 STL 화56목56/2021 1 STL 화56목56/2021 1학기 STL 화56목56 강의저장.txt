

===============================================
저장시간 : 2021-03-02 오후 3:01:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 2일 화요일				(1주 1일)
// 
// 실행될때마다 소스파일을 저장한다
//----------------------------------------------------------------------------------

#include <iostream>
#include <string>
#include <string_view>
#include <filesystem>
#include <fstream>
#include <ctime>
using namespace std;

void save(string_view );

int main()
{
	save("소스.cpp");
}

// google coding convention
void save( string_view fileName )
{
	// 어떤 파일을 저장하는지 화면에 출력한다. - 파일이름과 크기
	cout << "저장: " << fileName << ", 크기: " << filesystem::file_size(fileName) << endl;

	ofstream out("2021 1학기 STL 화56목56 강의저장.txt", ios::app);

	ifstream in(fileName); // 파일을 읽는다. <- 지역변수라 블록을 나가면 알아서 삭제 해줌

	out << endl << endl;

	// 파일을 기록한 시간도 쓴다.
	time_t t = time( nullptr );

	out.imbue(locale("korean"));

	out << "===============================================" << endl;
	out << "저장시간 : " << put_time( localtime(&t), "%c %A") << endl;
	out << "===============================================" << endl;
	int c;
	while ((c = in.get()) != EOF)
		out.put(c);

	// RAII
}


===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
#pragma once

#include <string_view>
void save(std::string_view);

===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
#include <iostream>
#include <filesystem>
#include <fstream>
#include "save.h"

// google coding convention
void save(std::string_view fileName)
{
	// 어떤 파일을 저장하는지 화면에 출력한다. - 파일이름과 크기
	std::cout << "저장: " << fileName << ", 크기: " << std::filesystem::file_size(fileName) << std::endl;

	std::ofstream out("2021 1학기 STL 화56목56 강의저장.txt", std::ios::app);

	std::ifstream in(fileName); // 파일을 읽는다. <- 지역변수라 블록을 나가면 알아서 삭제 해줌

	using std::endl;

	out << endl << endl;

	// 파일을 기록한 시간도 쓴다.
	time_t t = time(nullptr);

	out.imbue(std::locale("korean"));

	out << "===============================================" << endl;
	out << "저장시간 : " << std::put_time(localtime(&t), "%c %A") << endl;
	out << "===============================================" << endl;
	int c;
	while ((c = in.get()) != EOF)
		out.put(c);

	// RAII
}

===============================================
저장시간 : 2021-03-02 오후 3:10:21 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 2일 화요일				(1주 1일)
// 
// 실행될때마다 소스파일을 저장한다
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}


===============================================
저장시간 : 2021-03-04 오후 1:51:34 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// Game은 사용자가 정의한 클래스이다.
// 화면출력은 2, 1

int main()
{
	/*
	Game a{ 1 };
	Game b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	*/
	save("소스.cpp");
}


===============================================
저장시간 : 2021-03-04 오후 2:01:22 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// Game은 사용자가 정의한 클래스이다.
// 화면출력은 2, 1

class Game {
public:
	Game(int n) : n{ n } {}

private:
	int n;

	friend ostream& operator<<(ostream& os, const Game& game);
};


void change(Game&, Game&);

int main()
{
	Game a{ 1 };
	Game b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(Game& a, Game& b)
{
	Game temp{ a };
	a = b;
	b = temp;
}

ostream& operator<<(ostream& os, const Game& game)
{
	os << game.n;
	return os;
}

===============================================
저장시간 : 2021-03-04 오후 2:09:30 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
// 이번 시간 - C++ 언어 복습
// 많은 수의 데이터 다루기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] main()을 변경하지 않고 실행되도록 하자.
// 앞에서 만든 change()가 다른 자료형도 바꿀 수 있도록하자
// 화면출력은 2, 1

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:40:55 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10]{ 1,345456,48456465,846546,2 };

	for (int i = 0; i < 10; i++)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:44:10 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:46:20 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	cout << numeric_limits<int>::max() << endl;

	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:46:58 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	//int 최대값
	cout << numeric_limits<int>::max() << endl;
	//int 최소값
	cout << numeric_limits<int>::min() << endl;

	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid;

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:47:54 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 10개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[10];

	default_random_engine dre;
	uniform_int_distribution uid{ 0,100 };

	for (int i = 0; i < 10; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 10; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:53:06 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

int main()
{
	int a[100];

	default_random_engine dre;
	uniform_int_distribution uid{ 0,100 };

	cout << sizeof(dre) << endl;

	for (int i = 0; i < 100; ++i)
		a[i] = uid(dre);

	for (int i = 0; i < 100; ++i)
		cout << a[i] << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:56:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid;

	cout << sizeof(dre) << endl;

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:57:14 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 2:57:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 3:11:31 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 화면에 int 값을 출력하자
// 값을 오름차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort( begin(a), end(a) );

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-04 오후 3:16:42 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(1주 2일)
// 
// 1주 1일 강의 소스는 e-class 에 올리겠다
//
//
// 레퍼런스 - 한 지역에서 다른 지역의 객체에 access 하는 데 사용
//
// 많은 수의 데이터 다루기 - int에서 시작
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,1000 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		}/*어떻게 정렬할지 사용자가 알려주면 된다. -> 함수를 전달 */);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:38:06 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		}/*어떻게 정렬할지 사용자가 알려주면 된다. -> 함수를 전달 */);

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:38:38 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	// 정렬한다
	cout << "정렬합니다" << endl;
	sort(begin(a), end(a));

	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:18 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:40:41 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	sort(begin(a), end(a));

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:48:35 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

bool x(int a, int b)
{
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:50:33 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int xcount = 0;

bool x(int, int);

bool x(int a, int b)
{
	xcount++;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << xcount << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:52:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:52:38 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	cout << a << " -- " << b << endl;
	return a > b;
}

int main()
{
	int a[20];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 1:53:34 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

bool x(int, int);

static int cnt{};

bool x(int a, int b)
{
	cnt++;
	return a > b;
}

int main()
{
	int a[1000];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?

	bool x(int, int);
	sort(begin(a), end(a), x);	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:03:02 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 20개를 저장할 공간(20 * sizeof(int))을 마련한다.
// int를 임의의 값(랜덤엔진과 분포)으로 만들자
// 값을 내림차순으로 정렬하라
// 정렬결과를 출력하라

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1000];

	uniform_int_distribution uid{ 1,100 };

	for (int& n : a)
		n = uid(dre);

	cout << "정렬할 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl << endl;

	// 정렬한다
	// [문제] sort는 x를 몇 번 호출하는가?
	int cnt{};
	sort(begin(a), end(a), [&cnt](int a, int b) {
		++cnt;
		return a > b;
		});	// qsort

	cout << "x 호출횟수: " << cnt << endl;

	cout << "정렬한 자료" << endl;
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:10:15 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1000];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:12:15 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1'000];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:13:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int main()
{
	int a[1'000'00];

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:32:01 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[10'000'00]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:32:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[100'000'000]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:34:51 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int 1,000,000개를 저장할 공간을 마련하라.
// int를 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출룍하라.

//사이즈가 너무 커서 지역변수가 아니라 전역변수로 선언
default_random_engine dre;

int a[100'000'000]{};

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	cout << "처음 원소의 값 - " << *begin(a) << endl;
	cout << "마지막 원소의 값 - " << *(end(a) - 1) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:44:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <filesystem>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	std::ofstream out("int 100개.txt", std::ios::app);
	for (int n : a)
		out << n << " ";

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:48:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	ofstream out( "오름차순정렬한 int 100개.txt"s );
	for (int n : a)
		out << n;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:49:41 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] int 1000개를 전역메모리 공간에 저장하였다.
// 임의의 값(랜덤엔진과 분포)으로 채웠다
// 값을 오름차순으로 정렬하라
// 정렬된 값을 파일 "오름차순정렬한 int 100개.txt"에 저장하라
// (확인) 파일을 열어 결과를 확인할 것

default_random_engine dre;

int a[100];	//DATA segement에 100개 저장

int main()
{

	uniform_int_distribution uid;

	for (int& n : a)
		n = uid(dre);

	cout << "정렬시작" << endl;
	sort(begin(a), end(a));

	// 파일에 저장하라
	ofstream out( "오름차순정렬한 int 100개.txt"s );
	for (int n : a)
		out << n << ' ';

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 2:54:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{

	ifstream in("오름차순정렬한 int 100개.txt"s);
	int c;
	while ((c = in.get()) != EOF)
		cout << c;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:00:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}
	int c;
	while ((c = in.get()) != EOF)
		cout << c;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:01:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:03:08 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;

// [문제] 파일 "오름차순정렬한 int 100개.txt"가 있다.
// 읽어 화면 출력하라.

int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in( sv.data() );
	if (!in) {
		cout << sv << " 파일을 열 수 없습니다." << endl;
		exit(0);
	}

	int a[100];

	for (int& n : a)
		in >> n;

	for (int d : a)
		cout << d << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:14:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	for (int a : a)
		cout << a << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:16:12 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	ofstream out("int 100개.txt");

	out.write((char *)a, 100 * sizeof(int));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-09 오후 3:17:58 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 기록하라.
// 파일 크기는 400바이트가 되어야 한다.

int main()
{
	int a[100];

	iota(begin(a), end(a), 1);

	ofstream out("int 100개.txt", ios::binary);

	out.write((char *)a, 100 * sizeof(int));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:39:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개를 화면에 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int n;
	for (int i = 0; i < 100; i++){
		in.read((char *)&n, sizeof(int));
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:44:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 int 100개를 내림차순으로 정렬한 후 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int a[100];
	in.read((char*)a, 100 * sizeof(int));
	for (int n : a)
		cout << n << ' ';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:47:01 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 4일 목요일				(2주 1일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 int 100개를 내림차순으로 정렬한 후 출력하라.

int main()
{
	ifstream in{ "int 100개.txt"s, ios::binary };
	if (!in)
		exit(0);

	int a[100];
	in.read((char*)a, 100 * sizeof(int));
	
	sort(begin(a), end(a), [](int a, int b) {
		return a > b;
		});

	for (int x : a)
		cout << x << '\t';
	cout << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 2:14:19 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	cout << "몇 개의 int를 원하나요?";
	int num;
	cin >> num;

	int* p = new int[num];

	for (int i = 0; i < num; ++i)
		p[i] = i + 1;

	cout << "처음 - " << p[0] << endl;
	cout << "마지막 - " << p[num-1] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 2:15:52 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:16:12 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p = new int[num];

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:22:48 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다.
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력하라

int main()
{
	save("소스.cpp");
	while (true) {
		cout << "몇 개의 int를 원하나요?";
		int num;
		cin >> num;

		int* p;
		try{
			p = new int[num];
		}
		catch (exception& e) {
			cout << e.what() << endl;
			continue;
		}

		for (int i = 0; i < num; ++i)
			p[i] = i + 1;

		cout << "처음 - " << p[0] << endl;
		cout << "마지막 - " << p[num - 1] << endl;

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:40:33 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 조금씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[500'000'000];
		cout << ++cnt << " 할당 성공" << endl;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:44:23 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 
// 3초에 한번씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[200'000'000];
		cout << ++cnt << " 할당 성공" << endl;
		this_thread::sleep_for(3s);
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:47:53 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// [문제] 시스템이 메모리를 줄 수 있을때까지 메모리를 
// 3초에 한번씩 요청해본다.
// 해제하지 않고 500MB 를 계속 요청하자.
// 작업관리자 메모리 사용량을 확인하자 

int main()
{
	save("소스.cpp");

	int cnt{};

	while (true) {
		new char[200'000'000];
		cout << ++cnt << " 할당 성공" << endl;
		this_thread::sleep_for(1s);
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:56:50 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// core c++ guidelines - raw pointer 를 사용하지 말 것

int main()
{
	save("소스.cpp");

	int cnt{};
	while (true) {
		char* p = new char[500'000'000];

		cout << ++cnt << '\r';

		delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 2:58:47 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// core c++ guidelines - raw pointer 를 사용하지 말 것

int main()
{
	save("소스.cpp");

	int cnt{};
	while (true) {
		unique_ptr<char> p{ new char[500'000'000] };

		cout << ++cnt << '\r';

		//delete[] p;
	}
}

===============================================
저장시간 : 2021-03-11 오후 3:15:37 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(100ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간 - " << d.count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:18:00 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(100ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:18:34 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	chrono::steady_clock::time_point b = chrono::steady_clock::now();		// 스톱워치 시작

	this_thread::sleep_for(333ms);

	auto e = chrono::steady_clock::now();		// 스톱워치 끝

	auto d = e - b;

	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 3:20:36 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 11일 목요일				(2주 2일)
//
// 많은 수의 데이터 다루기 - int에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다,
//
// 다음시간 - sort() 설명 다시 - 함수의 역할 / 비교횟수등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;


int main()
{
	using namespace std::chrono;

	steady_clock::time_point b = steady_clock::now();		// 스톱워치 시작
	
	this_thread::sleep_for(333ms);

	auto d = steady_clock::now() - b;

	cout << "경과시간(밀리초) - " << duration_cast<milliseconds>(steady_clock::now() - b).count() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:46:08 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;
	string name;

	static int cnt;

friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:48:28 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	Dog(const Dog&) {
		cout << "복사" << endl;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:48:50 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// string name;		// Dog1 ~ Dog2000000
// int id;			// uid(dre)

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	Dog(const Dog&) {
		cout << "복사" << endl;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (Dog& dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:51:22 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// sizeof( Dog )를 확인하자


default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;
	string name;

	static int cnt;

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	cout << "Dog 한 객체가 차지하는 메모리 - " << sizeof(Dog) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 1:54:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// sizeof( Dog )를 확인하자


default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id( uid(dre) ) {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	char id;			// 1
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	cout << "Dog 한 객체가 차지하는 메모리 - " << sizeof(Dog) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:05:33 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10000];
	ofstream out("Dog 만객체.txt"s);
	for (const Dog& n : dogs)
		out << n << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:10:46 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	for (const Dog& dog : dogs)
		cout << dog << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:13:49 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// Dog 10'000객체를 만들어 "Dog 만객체.txt"에 저장하라
// 파일크기를 확인할것 - sizeof(Dog)*10'000

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	ofstream out{ "Dog 만객체.txt", ios::binary };
	out.write( (char *)&dogs[0], sizeof(Dog) * 100000);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:15:22 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10'000];

int main()
{
	ofstream out{ "Dog 만객체.txt", ios::binary };
	out.write( (char *)&dogs[0], sizeof(Dog) * 10'000);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:20:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	Dog* dogs = new Dog[10'000];

	in.read( (char *)dogs, sizeof(Dog) * 10'000);

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:34:24 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include <memory>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	~Dog() {
		cout << "소멸" << endl;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	unique_ptr<Dog[]> dogs{ new Dog[10'000] };

	in.read( (char *)dogs.get(), sizeof(Dog) * 10'000);

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:44:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 시간재는 코드 복습
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include <memory>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10'000 객체를 읽어라.
// id 오름차순으로 정렬해서 출력하라

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);

		++cnt;
	}

	int getID() const {
		return id;
	}

private:
	int id;			// 4
	string name;	// 24

	static int cnt;	// 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	ifstream in{ "Dog 만객체" };

	unique_ptr<Dog[]> dogs{ new Dog[10'000] };

	in.read( (char *)dogs.get(), sizeof(Dog) * 10'000);

	// id 오름차순으로 정렬한다.
	sort(&dogs[0], &dogs[10'000], [](const Dog& a, const Dog& b) {
		return a.getID() < b.getID();
		});

	for (int i = 0; i < 10'000; ++i)
		cout << dogs[i] << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:49:45 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	x();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:51:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	x();

	cout << typeid(x).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:53:44 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	auto x = []() {
		cout << "안녕" << endl; 
	};

	auto y = []() {
		cout << "안녕" << endl;
	};

	cout << typeid(x).name() << endl;
	cout << typeid(y).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:57:31 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) {
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	f(1);
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 2:58:11 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) {
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	(*f)(1);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:00:32 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	// f를 다른 변수 a에 저장할 수 있니?
	auto a = f;

	cout << typeid(a).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:02:18 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

int main()
{
	// f를 다른 변수 a에 저장할 수 있니?
	void(*a)(int) = f;

	a(123);

	cout << typeid(a).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:06:23 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}
};

int main()
{
	Test t;

	t(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:09:04 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}

	void  (*m)(int) = f;
};

int main()
{
	Test t;

	t(123);

	t.m(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:10:34 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

void f(int) 
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator() (int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}

	void  (*m)(int) = f;
};

auto x = [](int) -> void {
	cout << "람다" << endl;
};

int main()
{
	x(123);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-16 오후 3:14:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// 쿠키런
// 왼쪽버튼 - 점프, 오른쪽버튼 - 슬라이드
//
// 설정에 가서 버튼을 바꿨다.
// 프로그램 구현은 어떻게 했겠니?

void left()
{
	cout << "점프" << endl;
}

int main()
{
	save("소스.cpp");

	while (true) {
		left();
		this_thread::sleep_for(500ms);
	}
}

===============================================
저장시간 : 2021-03-16 오후 3:19:37 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 16일 화요일				(3주 1일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

// 쿠키런
// 왼쪽버튼 - 점프, 오른쪽버튼 - 슬라이드
//
// 설정에 가서 버튼을 바꿨다.
// 프로그램 구현은 어떻게 했겠니?

void jump() {
	cout << "점프" << endl;
}

void slide() {
	cout << "슬라이드" << endl;
}

void (*left_function)() = jump;

void left()
{
	left_function();
}

int main()
{
	save("소스.cpp");

	// 10번에 한번은 기능을 바꾼다

	int cnt{};

	while (true) {
		left();
		this_thread::sleep_for(500ms);
		++cnt;
		if (cnt == 10) {
			left_function = slide;
		}
	}
}

===============================================
저장시간 : 2021-03-18 오후 1:37:01 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

int main()
{
	int a;

	auto f = jump;

	cout << typeid(f).name() << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:47:27 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

int main()
{
	int a;

	void (*f)(void);

	cout << "함수 포인터의 크기 - "<< sizeof(f) << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:49:18 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:50:08 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "f의 번지 - " << f << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:50:55 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:51:54 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;
	cout << "변수 f의 번지 - " << &f <<endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:52:32 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
using namespace std;

void jump(void)
{
	cout << "점프합니다" << endl;
}

void slide(void)
{
	cout << "슬라이드합니다." << endl;
}

int main()
{
	void (*f)(void);

	f = jump;
	f();

	cout << "main번지 - " << main << endl;
	cout << "f의 번지 - " << f << endl;
	cout << "변수 f의 번지 - " << &f <<endl;

	int a;
	cout << "스택의 번지 - " << &a << endl;

	f = slide;
	f();

	f();

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 1:59:27 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

int main()
{
	f(1);
	Test t;
	t(2);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:03:48 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
void (*lamda)(int) = [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);
	//질문? 람다의 타입은?

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:06:09 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
public:
	void operator()(int) {
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);
	//질문? 람다의 타입은?
	cout << typeid(lamda).name() << endl;
	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:13:37 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

int main()
{
	f(1);

	Test t;
	t(2);

	lamda(3);

	t.mf(4);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:18:41 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	void (*ct)(int) = f;
	ct(1);

	//Test t;
	//ct = void ((*t)) (int)

	//ct(2);
	
	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);

	// ct = &Test::mf;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:33:26 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}

	void mf(int) {
		cout << "Test의 멤버를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	void (*ct)(int) = f;
	ct(1);

	Test t;
	//ct = void ((*t)) (int)

	//ct(2);
	
	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);

	void (Test::*pmf)(int) = &Test::mf;
	(t.*pmf)(4);

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 2:43:22 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"
using namespace std;

// 1. 일반함수
void f(int)
{
	cout << "일반함수를 호출하였다." << endl;
}

// 2. 함수 객체
class Test {
	int cnt{};
public:
	void operator()(int) {
		++cnt;
		cout << "()연산자를 오버로딩한 클래스를 호출하였다." << endl;
	}
};

// 3. 람다
auto lamda= [](int) {
	cout << "람다를 호출하였다." << endl;
	};

// [문제] callable type에 각 함수를 저장했다가 호출해보라.

int main()
{
	function<void(int)> ct;

	ct = f;
	ct(1);

	Test t;
	ct = t;
	ct(2);

	// 3. 람다
	ct = [](int) {
		cout << "람다를 호출하였다." << endl;
	};
	ct(3);


	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:00:49 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,255 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:29 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,255 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,100 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:43 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,100 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:01:51 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:18 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << &game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:33 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << *game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:02:50 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

default_random_engine dre;
uniform_int_distribution uid{ 0,60 };

class String {
public:
	char* a;

	String(int num)
	{
		a = new char[num];
		for (int i = 0; i < num; i++)
		{
			a[i] = uid(dre);
			cout << a[i] << endl;
		}
	}

	~String()
	{
		delete[] a;
	}

private:
	friend ostream& operator<<(ostream& os, const String& game);
};

ostream& operator<<(ostream& os, const String& game)
{
	os << game.a;
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:10:39 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s{ 30 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:10:59 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s{ 2021 };

	cout << s << endl;	//화면에 임의의 소문자 30글자가 출력되어야

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:13:15 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for ( String s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:14:15 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-18 오후 3:18:03 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 18일 목요일				(3주 2일)
//
// 호출가능한 타입 - callable type
//  - STL에서는 이것을 알고리즘 함수의 동작을 변형하는 용도로 사용한다.
//
//    sort(bgin, end, 어떤순서로)
//
// 호출할 수 있는 타입이 무한하고 서로 다른데 통일할 수 있으면 좋겠다?
//-> function 타입이 만들어진 이유
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 1:50:43 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	for (String& s : s)
		cout << s << endl;

	cout << endl << "---------------------" << endl;
	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 1:52:01 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	//sort(begin(s), end(s), [](const String& a, const String& b){
	//	return a.size() < b.size();
	//	});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:05:47 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:15:05 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending()
	{
		sort(p, p + num, [](const char& a, const char& b) {
			return a < b;
			});
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	// [문제] 각 String을 알파벳 오름차순으로 정렬하라.
	for (String& s : s)
		s.sortAscending();

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:31:20 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };

#define SHOW

class String {
public:
	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

int main()
{

	String s[10]{ 20, 21, 3, 18, 7, 8, 3, 12, 33, 55 };

	// 길이 오름차순으로 정렬하라
	sort(begin(s), end(s), [](const String& a, const String& b){
		return a.size() < b.size();
		});

	// [문제] 각 String을 알파벳 오름차순으로 정렬하라.
	for (String& s : s)
		s.sortAscending();

	for ( String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:39:54 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };
uniform_int_distribution<> uidLen{ 1, 200 };

class String {
public:
	String() : num{ uidLen(dre) }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() < b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:40:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <random>
#include <functional>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자

mt19937 dre;

uniform_int_distribution<> uid{ 'a', 'z' };
uniform_int_distribution<> uidLen{ 1, 200 };

class String {
public:
	String() : num{ uidLen(dre) }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	String(int num) : num{ num }, p{ new char[num] } {
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}

	~String(){
		delete[] p;
	}

	String(const String& other) : num{ other.num }, p{ new char[num] } {
		// cout << "복사";		// swithch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator = (const String& other){
		// cout << "할당";
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}
		return *this;
	}

	size_t size() const {
		return num;
	}

	void String::sortAscending() {
		sort(p, p + num);
	}

private:
	int num {0};
	char* p{ nullptr };


	friend ostream& operator<<(ostream& os, const String&);
};

ostream& operator<<(ostream& os, const String& s)
{
	for (int i=0; i< s.num; ++i)
		os << s.p[i];
	return os;
}

// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() > b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:44:05 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num 바이트 할당받아
// 임의의 알파벳 소문자로 채우는 클래스 String을 코딩하라.
//
// 다음 main()이 의도대로 실행되게 하자



// String 객체 100개를 [1~200] 까지의 랜덤값으로 생성하라.
// 길이오름차순으로 정렬하고 각 객체는 알파벳 오름차순으로 정렬하라.

int main()
{
	String s[100];

	for (String& s : s)
		s.sortAscending();

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() > b.size();
		});

	for (const String& s : s)
		cout << s << endl;

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:59:19 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 사용자가 입력하는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{}, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 3:01:09 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 사용자가 입력하는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>{ cin}, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 3:05:06 화요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{ in }, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-25 오전 9:34:09 목요일
===============================================
//----------------------------------------------------------------------------------
// 앞으로 x86 release mode 에서 프로그램한다..
//
// 2021. 1학기 STL 화56 목56 - 3월 23일 화요일				(4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//----------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 모두 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{ in }, {} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	save("소스.cpp");
}